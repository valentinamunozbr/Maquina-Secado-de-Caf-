//ntp con dht trama cada 10 seg, freertos y dht11

#include <WiFi.h>
#include "time.h"
#include "DHT.h"

// ====== CONFIG WIFI Y NTP (Colombia UTC-5, sin DST) ======
const char* ssid     = "TP-LINK_DDAE";
const char* password = "24890717";
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = -5 * 3600;
const int   daylightOffset_sec = 0;

// ====== DHT11 ======
#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// ====== ACUMULADORES PROMEDIOS ======
float tempSum = 0;
int   tempCount = 0;

float humSum  = 0;
int   humCount = 0;

// Mutex para proteger acumulos
SemaphoreHandle_t dataMutex;

// ====== PROTOTIPOS ======
void tareaTemperatura(void * parameter);
void tareaHumedad(void * parameter);
void tareaTrama(void * parameter);

void setup() {
  Serial.begin(115200);
  delay(100);

  // WiFi
  Serial.print("Conectando a WiFi: "); Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado");

  // NTP
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  // DHT
  dht.begin();

  // Mutex
  dataMutex = xSemaphoreCreateMutex();

  // ====== TAREAS FREERTOS ======
  xTaskCreatePinnedToCore(tareaTemperatura, "TempTask", 4096, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(tareaHumedad,    "HumTask",  4096, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(tareaTrama,      "TramaTask",4096, NULL, 1, NULL, 1);

  Serial.println("Sistema iniciado.");
}

void loop() {
  // Nada: FreeRTOS gestiona las tareas
}

// ====== TAREA: TEMPERATURA cada 2 s ======
void tareaTemperatura(void * parameter) {
  for(;;) {
    float t = dht.readTemperature();
    if (!isnan(t)) {
      xSemaphoreTake(dataMutex, portMAX_DELAY);
      tempSum += t;
      tempCount++;
      xSemaphoreGive(dataMutex);
    }
    vTaskDelay(pdMS_TO_TICKS(2000)); // 2 s
  }
}

// ====== TAREA: HUMEDAD cada 1.5 s ======
void tareaHumedad(void * parameter) {
  for(;;) {
    float h = dht.readHumidity();
    if (!isnan(h)) {
      xSemaphoreTake(dataMutex, portMAX_DELAY);
      humSum += h;
      humCount++;
      xSemaphoreGive(dataMutex);
    }
    vTaskDelay(pdMS_TO_TICKS(1500)); // 1.5 s
  }
}

// ====== TAREA: TRAMA cada 10 s ======
void tareaTrama(void * parameter) {
  for(;;) {
    vTaskDelay(pdMS_TO_TICKS(10000)); // 10 s

    // Obtener y limpiar promedios acumulados
    float avgTemp = NAN, avgHum = NAN;
    xSemaphoreTake(dataMutex, portMAX_DELAY);
    if (tempCount > 0) avgTemp = tempSum / tempCount;
    if (humCount  > 0) avgHum  = humSum  / humCount;
    tempSum = 0; tempCount = 0;
    humSum  = 0; humCount  = 0;
    xSemaphoreGive(dataMutex);

    // Estado por defecto OK
    int estado = 1;

    // Timestamp
    struct tm timeinfo;
    if(!getLocalTime(&timeinfo)){
      estado = 0;
      memset(&timeinfo, 0, sizeof(timeinfo));
      timeinfo.tm_year = 125; // 2025 - 1900
      timeinfo.tm_mon  = 0;   // enero
      timeinfo.tm_mday = 1;
    }

    char timestamp[24];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", &timeinfo);

    // Validar lecturas
    if (isnan(avgTemp)) { avgTemp = -999.9; estado = 0; }
    if (isnan(avgHum))  { avgHum  = -999.9; estado = 0; }

    // ====== TRAMA ======
    Serial.print("TRAMA -> ");
    Serial.print(timestamp);
    Serial.print(" | Temp: "); Serial.print(avgTemp, 1);
    Serial.print(" | Hum: ");  Serial.print(avgHum, 1);
    Serial.print(" | Estado: "); Serial.println(estado);
  }
}

