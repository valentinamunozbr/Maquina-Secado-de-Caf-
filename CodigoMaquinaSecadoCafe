/** 
 * @file Secador_Cafe_Doxygen.cpp
 * @brief Secador de Café (ESP32) con documentación Doxygen.
 *
 * Este archivo contiene la implementación del sistema de secado de café
 * usando un ESP32. Incluye la lectura de sensores (DS18B20 y DHT22),
 * control de temperatura mediante un módulo Peltier (PWM), movimiento de
 * una malla mediante un servomotor, RTC para timestamps, servidor web
 * local y envíos periódicos de promedios a un endpoint remoto.
 *
 * La documentación con Doxygen describe las estructuras, variables globales,
 * funciones y tareas FreeRTOS para facilitar la generación de la documentación
 * técnica y el entendimiento del sistema.
 *
 * @author
 *   Juan Jose Gomez, Cesar Guerrero, Valentina Muñoz, Sara Sanchez
 * @date 2025-10-02
 * @version 1.1
 */

#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Wire.h>
#include <RTClib.h>
#include <time.h>
#include <RunningAverage.h>
#include <ESP32Servo.h>
#include <DHT.h>
#include <esp_sleep.h>             ///< Light sleep
#include <driver/ledc.h>           ///< Driver LEDC (ESP-IDF) para PWM
#include <esp32-hal-timer.h>       ///< API vieja de timers (timerBegin(frequency))

// ================== WIFI / ENDPOINT ==================
const char* WIFI_SSID      = "TU_SSID";                 ///< SSID Wi-Fi (MODIFICAR)
const char* WIFI_PASS      = "TU_PASSWORD";             ///< Password Wi-Fi (MODIFICAR)
const char* HTTP_POST_URL  = "http://tu-servidor.com/mediciones/promedio"; ///< URL opcional para POST

// ================== Zona horaria y NTP ==================
static const long   GMT_OFFSET_SEC = -5 * 3600;         ///< Offset GMT (ej: Colombia -5)
static const int    DST_OFFSET_SEC = 0;                 ///< DST si aplica
static const char*  NTP1 = "pool.ntp.org";              ///< NTP primario
static const char*  NTP2 = "time.nist.gov";             ///< NTP secundario

// ================== Pines de hardware ==================
#define PIN_ONEWIRE     4   ///< DS18B20 (interno)
#define PIN_DHT         5   ///< DHT22 (ambiente)
#define PIN_PELTIER     23  ///< PWM hacia driver Peltier (usar MOSFET/driver externo)
#define PIN_SERVO       18  ///< Servo de la malla
#define PIN_LED_ALARMA  2   ///< LED de alarma

// ================== Sensores / periféricos ==================
/** @defgroup periph Sensores y perifericos
 *  @brief Instancias de sensores y RTC.
 *  @{
 */
OneWire oneWire(PIN_ONEWIRE);              ///< Interfaz OneWire DS18B20
DallasTemperature ds18b20(&oneWire);       ///< Driver DS18B20
RTC_DS1307 rtc;                            ///< RTC

#define DHTTYPE DHT22
DHT dht(PIN_DHT, DHTTYPE);                 ///< Instancia DHT22
bool rtc_ok = false;                       ///< Indica si el RTC esta disponible
/** @} */

// ================== Servo (malla) ==================
/** @defgroup servo Servo de malla
 *  @brief Parametros y estado del servo.
 *  @{
 */
Servo   meshServo;                         ///< Servo de la malla
int     SERVO_MIN_DEG  = 30;               ///< Posición mínima (grados)
int     SERVO_MAX_DEG  = 150;              ///< Posición máxima (grados)
int     SERVO_STEP_DEG = 5;                ///< Paso por iteración (grados)
uint32_t SERVO_STEP_MS = 200;              ///< Delay entre pasos (ms)
int     servoPos = 30;                     ///< Posición actual
int     servoDir = +1;                     ///< Dirección de barrido
/** @} */

// ================== Parámetros PWM Peltier ==================
/** @defgroup peltier PWM Peltier
 *  @brief Parametros de PWM LEDC para calefaccion.
 *  @{
 */
const int LEDC_FREQ_HZ  = 5000;            ///< Frecuencia PWM
const int LEDC_RES_BITS = 8;               ///< Resolución PWM (bits) -> duty 0..255
uint8_t   peltierDuty   = 0;               ///< Duty actual (0..255)
/** @} */

// ================== FreeRTOS IPC ==================
/** @defgroup rtos RTOS: tareas y sincronizacion
 *  @brief Handles de tareas, colas, semaforos, mutex.
 *  @{
 */
static TaskHandle_t hSensorTask   = nullptr; ///< Tarea sensores
static TaskHandle_t hControlTask  = nullptr; ///< Tarea control
static TaskHandle_t hLoggerTask   = nullptr; ///< Tarea logger
static TaskHandle_t hSenderTask   = nullptr; ///< Tarea envíos/UI
static TaskHandle_t hServoTask    = nullptr; ///< Tarea servo

static QueueHandle_t      qSensors = nullptr; ///< Cola de última muestra
static SemaphoreHandle_t  semCtrl  = nullptr; ///< Semáforo de control (timer)
static SemaphoreHandle_t  snapMtx  = nullptr; ///< Mutex de snapshot
/** @} */

// ================== Timer HW (API vieja) ==================
/** @defgroup timers Timers
 *  @brief Timer HW de control.
 *  @{
 */
hw_timer_t* ctrlTimer = nullptr;           ///< Timer de control
/** @} */

// ================== Parámetros de control ==================
/** @defgroup control Parametros de control
 *  @brief Setpoints y periodos.
 *  @{
 */

float    T_SET_C          = 45.0f;         ///< Setpoint de temperatura interna (degC)
float    T_HYST_C         = 1.5f;          ///< Banda de histéresis (degC)
uint8_t  HEAT_FULL_DUTY   = 255;           ///< Duty al encender calefacción

// Ritmos de sensado
uint32_t DS18_PERIOD_MS   = 10000;         ///< Periodo DS18B20 (ms)
uint32_t DHT_PERIOD_MS    = 60000;         ///< Periodo DHT22 (ms)

// Tick de control (timer ISR)
uint32_t CTRL_TICK_MS     = 30000;         ///< Periodo de control (ms)

// Transmisión / ventana Web
uint32_t TX_PERIOD_S      = 600;           ///< Periodo de envío de promedios (s)
uint32_t TX_WINDOW_MS     = 8000;          ///< Ventana con server.begin() activo (ms)
/** @} */

// ================== Estructuras ==================
/**
 * @brief Paquete con la ultima muestra de sensores.
 */
struct SensorFrame {
  uint32_t ts;     ///< timestamp (epoch s)
  float    t_ds18; ///< temperatura interna (DS18B20) degC
  float    t_dht;  ///< temperatura ambiente (DHT22) degC
  float    h_dht;  ///< humedad ambiente (%)
  bool     valid_ds18; ///< lectura DS18 válida
  bool     valid_dht;  ///< lectura DHT válida
};

static SensorFrame gSnap = {};   ///< snapshot para UI (protegida)
static uint8_t     gSnapDuty = 0;
static int         gSnapServo = 0;

// ================== Promedios (10 min) ==================
RunningAverage avg_Tint(120);    ///< Tin 10 min (aprox 60 muestras si 10s)
RunningAverage avg_Tamb(20);     ///< Tamb 10 min
RunningAverage avg_H(20);        ///< Humedad 10 min
uint32_t       avg_last_ts = 0;  ///< ts de última muestra para promedio

// ================== HTTP Server (UI) ==================
WebServer server(80);

/** @brief Pagina HTML simple para monitoreo local. */
static const char INDEX_HTML[] PROGMEM = R"UI(
<!doctype html><html lang="es"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Secador de Café</title>
<style>
body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:16px}
.card{border:1px solid #ddd;border-radius:12px;padding:16px;margin-bottom:12px;box-shadow:0 2px 8px rgba(0,0,0,.05)}
.row{display:flex;gap:12px;flex-wrap:wrap}.box{flex:1 1 220px;border:1px solid #eee;border-radius:10px;padding:12px}
.label{color:#666}.value{font-size:1.5rem;margin-top:4px}.on{color:#0b78ff}.off{color:#999}small{color:#666}
</style></head><body>
<h1>Secador de Café — Monitoreo</h1>
<div class="card"><div class="row">
  <div class="box"><div class="label">Temp café (DS18B20, dentro)</div><div id="t_ds18" class="value">— °C</div></div>
  <div class="box"><div class="label">Temp aire entrada (DHT22, fuera)</div><div id="t_dht" class="value">— °C</div></div>
  <div class="box"><div class="label">Humedad aire (DHT22, fuera)</div><div id="h_dht" class="value">— %</div></div>
  <div class="box"><div class="label">Peltier duty</div><div id="duty" class="value">— %</div></div>
  <div class="box"><div class="label">Servo (malla)</div><div id="servo" class="value">— °</div></div>
</div><div style="margin-top:8px"><small id="ts">—</small></div></div>
<script>
async function refresh(){
  try{
    const r = await fetch('/api/last',{cache:'no-store'}); if(!r.ok) return;
    const j = await r.json(); const f=v=>v==null||Number.isNaN(v)?'—':(Math.round(v*100)/100);
    t_ds18.textContent = f(j.t_ds18)+' °C';
    t_dht.textContent  = f(j.t_dht) +' °C';
    h_dht.textContent  = f(j.h_dht) +' %';
    duty.textContent   = (j.duty!=null)? (Math.round(j.duty*100)/100)+' %' : '— %';
    servo.textContent  = (j.servo!=null)? (j.servo+' °') : '— °';
    ts.textContent     = j.ts?('Última muestra: '+new Date(j.ts*1000).toLocaleString()):'—';
  }catch(e){}
}
refresh(); setInterval(refresh, 2000);
</script></body></html>
)UI";

// ================== Utilidades ==================

/**
 * @brief Checksum XOR simple de una cadena.
 * @param s Cadena de entrada.
 * @return uint8_t con el XOR de todos los bytes.
 */

static uint8_t simple_xor_checksum(const String &s) {
  uint8_t x = 0; for (size_t i=0;i<s.length();++i) x ^= (uint8_t)s[i]; return x;
}

/**
 * @brief Construye JSON con la ultima snapshot para /api/last.
 * @return String JSON con campos ts, t_ds18, t_dht, h_dht, duty, servo.
 */

String jsonLast() {
  SensorFrame s; uint8_t duty; int sdeg;
  if (snapMtx && xSemaphoreTake(snapMtx, pdMS_TO_TICKS(50)) == pdTRUE) {
    s = gSnap; duty = gSnapDuty; sdeg = gSnapServo; xSemaphoreGive(snapMtx);
  } else { s = {}; duty = 0; sdeg = 0; }

  auto f = [](float v)->String {
    if (isnan(v)) return "null";
    char b[24]; dtostrf(v,0,2,b);
    String sv(b); sv.replace(" ",""); return sv;
  };

  String j; j.reserve(200);
  j += '{';
  j += "\"ts\":";     j += String(s.ts ? s.ts : 0); j += ',';
  j += "\"t_ds18\":"; j += (s.valid_ds18?f(s.t_ds18):"null"); j += ',';
  j += "\"t_dht\":";  j += (s.valid_dht ?f(s.t_dht) :"null"); j += ',';
  j += "\"h_dht\":";  j += (s.valid_dht ?f(s.h_dht) :"null"); j += ',';
  j += "\"duty\":";   j += String((100.0f * duty) / 255.0f, 1); j += ',';
  j += "\"servo\":";  j += String(sdeg);
  j += '}';
  return j;
}

/**
 * @brief Handler HTTP para la pagina principal.
 */
void handleIndex(){ server.send(200,"text/html; charset=utf-8",INDEX_HTML); }

/**
 * @brief Handler HTTP para /api/last (JSON).
 */
void handleApiLast(){ server.send(200,"application/json",jsonLast()); }

// -------------------- PWM Peltier con driver LEDC (IDF) --------------------
/**
 * @brief Ajusta el duty del Peltier por LEDC y guarda el valor global.
 * @param duty Valor 0..255 (8 bits).
 */
static void peltier_setDuty(uint8_t duty){
  peltierDuty = duty;
  ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
}


// -------------------- ISR Timer control --------------------
/**
 * @brief ISR del timer de control. Libera el semaforo para despertar la tarea de control.
 * @note Mantener lo mas corto posible.
 */
void IRAM_ATTR onCtrlTimer(){
  BaseType_t hpw=pdFALSE; xSemaphoreGiveFromISR(semCtrl,&hpw);
#if defined(portYIELD_FROM_ISR)
  if(hpw) portYIELD_FROM_ISR();
#else
  if(hpw) portYIELD();
#endif
}


// -------------------- WiFi / NTP helpers --------------------

/**
 * @brief Conecta a Wi-Fi con timeout de 15 s.
 * @return true si se conecto; false en caso contrario.
 */
bool wifiConnect(){
  WiFi.mode(WIFI_STA); WiFi.begin(WIFI_SSID, WIFI_PASS);
  uint32_t t0=millis(); Serial.print("Wi-Fi conectando");
  while(WiFi.status()!=WL_CONNECTED && millis()-t0<15000){ Serial.print("."); delay(250); }
  Serial.println();
  if(WiFi.status()==WL_CONNECTED){ Serial.print("Wi-Fi IP: "); Serial.println(WiFi.localIP()); return true; }
  Serial.println("Wi-Fi FAIL"); return false;
}

/**
 * @brief Apaga Wi-Fi para ahorrar energia.
 */
void wifiOff(){ WiFi.disconnect(true); WiFi.mode(WIFI_OFF); }

/**
 * @brief Sincroniza hora via NTP una unica vez y ajusta RTC si existe.
 * @return true si la hora es valida; false si fracaso.
 */
bool ntpSyncOnce(){
  if(!wifiConnect()) return false;
  configTime(GMT_OFFSET_SEC, DST_OFFSET_SEC, NTP1, NTP2);
  time_t now=0; uint32_t t1=millis();
  do{ now=time(nullptr); delay(200);}while(now<1577836800 && millis()-t1<8000);
  if(now<1577836800){ Serial.println("NTP FAIL"); return false; }
  if(rtc_ok){
    struct tm* tm_now = localtime(&now);
    DateTime dt(1900+tm_now->tm_year, tm_now->tm_mon+1, tm_now->tm_mday,
                tm_now->tm_hour, tm_now->tm_min, tm_now->tm_sec);
    rtc.adjust(dt);
  }
  return true;
}

// ================== Estabilidad (sleep) ==================
static float last_log_temp = NAN;  ///< última Tin registrada
static float last_log_hum  = NAN;  ///< última H registrada
static int   stable_count  = 0;    ///< conteo de logs estables
const  int   STABLE_REQUIRED = 3;  ///< logs consecutivos requeridos
const  float STABLE_DELTA_T  = 0.5;///< delta Tin estable
const  float STABLE_DELTA_H  = 1.0;///< delta H estable

// ================== TAREAS ==================
/**
 * @brief Tarea de sensado: DS18B20 cada 10 s y DHT22 cada 60 s.
 * - Actualiza promedios (RunningAverage).
 * - Publica la ultima muestra en la cola qSensors.
 * @param pv No usado.
 */

void SensorTask(void*){
  TickType_t lastDS  = xTaskGetTickCount();
  TickType_t lastDHT = xTaskGetTickCount();

  for(;;){
    SensorFrame frame{}; bool sent=false;

    // timestamp con fallback (RTC -> time() -> millis)
    DateTime now = rtc.now();
    uint32_t ts_now = now.unixtime();
    if (ts_now < 1577836800U) {
      time_t tnow = time(nullptr);
      ts_now = (tnow >= 1577836800) ? (uint32_t)tnow : (millis()/1000);
    }
    frame.ts = ts_now;

    // DS18B20 cada 10 s (conversión ~750 ms a 12 bits)
    if(xTaskGetTickCount() - lastDS >= pdMS_TO_TICKS(DS18_PERIOD_MS)){
      ds18b20.requestTemperatures();
      vTaskDelay(pdMS_TO_TICKS(750));
      float t = ds18b20.getTempCByIndex(0);
      if(!isnan(t) && t>-55 && t<125){
        frame.t_ds18=t; frame.valid_ds18=true;
        avg_Tint.addValue(t);
        avg_last_ts = frame.ts;
      } else frame.valid_ds18=false;
      lastDS = xTaskGetTickCount(); sent=true;
    }

    // DHT22 cada 60 s
    if(xTaskGetTickCount() - lastDHT >= pdMS_TO_TICKS(DHT_PERIOD_MS)){
      float h=dht.readHumidity(), ta=dht.readTemperature();
      if(!isnan(h) && !isnan(ta) && ta>-40 && ta<80 && h>=0 && h<=100){
        frame.t_dht=ta; frame.h_dht=h; frame.valid_dht=true;
        avg_Tamb.addValue(ta);
        avg_H.addValue(h);
        avg_last_ts = frame.ts;
      } else frame.valid_dht=false;
      lastDHT = xTaskGetTickCount(); sent=true;
    }

    if(sent){
      if(qSensors) xQueueOverwrite(qSensors,&frame);
      if(hLoggerTask) xTaskNotifyGive(hLoggerTask);
    }
    vTaskDelay(pdMS_TO_TICKS(150));
  }
}

/**
 * @brief Tarea de control: histeresis sobre Tin para encender/apagar Peltier.
 * @param pv No usado.
 */
void ControlTask(void*){
  SensorFrame cur{};
  for(;;){
    xSemaphoreTake(semCtrl, portMAX_DELAY);

    SensorFrame rx;
    if(xQueueReceive(qSensors,&rx,0)==pdPASS){
      if(rx.valid_ds18) cur.t_ds18 = rx.t_ds18;
      if(rx.ts)         cur.ts = rx.ts;
    }

    float Tin = cur.t_ds18;
    if(!isnan(Tin)){
      if(Tin < (T_SET_C - T_HYST_C))      peltier_setDuty(HEAT_FULL_DUTY);
      else if (Tin > (T_SET_C + T_HYST_C)) peltier_setDuty(0);
    }
    if(hLoggerTask) xTaskNotifyGive(hLoggerTask);
  }
}


/**
 * @brief Tarea de logging y snapshot para UI.
 * - Imprime linea de estado con checksum por Serial.
 * - Actualiza gSnap/gSnapDuty/gSnapServo para /api/last.
 * - LED de alarma simple.
 * - Entra a light sleep 10 s si hay estabilidad por varios ciclos.
 * @param pv No usado.
 */
void LoggerTask(void*){
  for(;;){
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    SensorFrame s{};
    if(xQueuePeek(qSensors,&s,0)==pdPASS){
      if(snapMtx && xSemaphoreTake(snapMtx,pdMS_TO_TICKS(20))==pdTRUE){
        gSnap=s; gSnapDuty=peltierDuty; gSnapServo=servoPos;
        xSemaphoreGive(snapMtx);
      }

      // hora segura
      DateTime dt = rtc.now();
      time_t tnow = dt.unixtime();
      if (tnow < 1577836800U) {
        time_t w = time(nullptr);
        tnow = (w >= 1577836800) ? w : (time_t)(millis()/1000);
      }
      struct tm tm_now; gmtime_r(&tnow, &tm_now);

      // log de estado + checksum
      char timebuf[32];
      snprintf(timebuf, sizeof(timebuf), "[%04d-%02d-%02d %02d:%02d:%02d]",
               tm_now.tm_year+1900, tm_now.tm_mon+1, tm_now.tm_mday,
               tm_now.tm_hour, tm_now.tm_min, tm_now.tm_sec);

      if (!s.valid_ds18 && !s.valid_dht) {
        Serial.printf("%s STATUS:ERR_SENSORS\n", timebuf);
      } else {
        String payload;
        payload.reserve(128);
        payload += String(timebuf);
        payload += " STATUS:OK;";
        payload += (s.valid_ds18 ? ("Tin:"+String(s.t_ds18,2)+"C;") : "Tin:ERR;");
        payload += (s.valid_dht  ? ("Tamb:"+String(s.t_dht,2)+"C;H:"+String(s.h_dht,1)+"%;") : "Tamb:ERR;H:ERR;");
        payload += "Duty:" + String(peltierDuty) + ";Servo:" + String(servoPos);

        uint8_t csum = simple_xor_checksum(payload);
        char hexbuf[5]; snprintf(hexbuf, sizeof(hexbuf), "%02X", csum);
        payload += ";CSUM:0x"; payload += String(hexbuf);
        Serial.println(payload);

        // alarma simple
        bool alarm = false;
        if (s.valid_ds18 && s.t_ds18 > (T_SET_C + 5.0f)) alarm = true;
        if (s.valid_dht  && s.h_dht  > 85.0f)            alarm = true;
        digitalWrite(PIN_LED_ALARMA, alarm ? HIGH : LOW);

        // estabilidad -> light sleep 10s
        if (s.valid_ds18 && s.valid_dht) {
          float t = s.t_ds18, h = s.h_dht;
          if (!isnan(last_log_temp) && !isnan(last_log_hum)) {
            if (fabs(t - last_log_temp) < STABLE_DELTA_T && fabs(h - last_log_hum) < STABLE_DELTA_H) {
              stable_count++;
            } else stable_count = 0;
          } else stable_count = 0;

          last_log_temp = t; last_log_hum = h;

          if (stable_count >= STABLE_REQUIRED) {
            Serial.println("Estable -> Light sleep 10s");
            esp_sleep_enable_timer_wakeup(10ULL * 1000000ULL);
            esp_light_sleep_start();
            stable_count = 0;
          }
        }
      }
    }
  }
}

/**
 * @brief Tarea de barrido del servo entre SERVO_MIN_DEG y SERVO_MAX_DEG.
 * @param pv No usado.
 */
void ServoTask(void*){
  for(;;){
    servoPos += servoDir * SERVO_STEP_DEG;
    if(servoPos >= SERVO_MAX_DEG){ servoPos = SERVO_MAX_DEG; servoDir = -1; }
    if(servoPos <= SERVO_MIN_DEG){ servoPos = SERVO_MIN_DEG; servoDir = +1; }
    meshServo.write(servoPos);
    vTaskDelay(pdMS_TO_TICKS(SERVO_STEP_MS));
  }
}

void SenderTask(void*){
  uint32_t lastTx_ms = millis(); static bool ntpDone=false;
  for(;;){
    uint32_t now=millis(), elapsed=now-lastTx_ms;
    uint32_t wait_ms = (TX_PERIOD_S*1000>elapsed) ? (TX_PERIOD_S*1000-elapsed) : 0;
    vTaskDelay(pdMS_TO_TICKS(wait_ms));
    lastTx_ms = millis();

    if(!wifiConnect()) continue;
    if(!ntpDone){ if(ntpSyncOnce()) ntpDone=true; }

    // activar UI local durante la ventana
    server.begin();
    Serial.println("HTTP local: http://" + WiFi.localIP().toString());

    // promedios 10 min
    size_t nTin=avg_Tint.getCount(), nTam=avg_Tamb.getCount(), nH=avg_H.getCount();
    if(nTin+nTam+nH>0){
      float mTin=(nTin>0)?avg_Tint.getAverage():NAN;
      float mTam=(nTam>0)?avg_Tamb.getAverage():NAN;
      float mH  =(nH  >0)?avg_H.getAverage():NAN;
      uint32_t tsSend=(avg_last_ts>0)?avg_last_ts:(uint32_t)(time(nullptr));

      String payload="{";
      payload+="\"ts\":"+String(tsSend)+",";
      payload+="\"Tin\":"+String(mTin,2)+",";
      payload+="\"Tamb\":"+String(mTam,2)+",";
      payload+="\"H\":"+String(mH,2);
      payload+="}";

      HTTPClient http;
      http.begin(HTTP_POST_URL);
      http.addHeader("Content-Type","application/json");
      int code=http.POST((uint8_t*)payload.c_str(),payload.length());
      Serial.printf("POST promedio -> code=%d, payload=%s\n",code,payload.c_str());
      http.end();

      avg_Tint.clear(); avg_Tamb.clear(); avg_H.clear(); avg_last_ts=0;
    }

    uint32_t t0=millis();
    while(millis()-t0 < TX_WINDOW_MS){
      server.handleClient();
      vTaskDelay(pdMS_TO_TICKS(10));
    }
    server.stop();
    wifiOff();
    Serial.println("Ventana cerrada (Wi-Fi OFF).");
  }
}

// ================== SETUP / LOOP ==================
/**
 * @brief Inicializacion general: PWM LEDC, Servo, Sensores, RTC, RTOS y rutas HTTP.
 */
void setup(){
  Serial.begin(115200); delay(200);
  Serial.println("CoffeeDryer FreeRTOS (Tin DS18B20 + DHT22 + Servo + Peltier + Promedios)");

  // ---------- PWM Peltier con driver LEDC (IDF) ----------
  ledc_timer_config_t tcfg = {};
  tcfg.speed_mode       = LEDC_LOW_SPEED_MODE;
  tcfg.timer_num        = LEDC_TIMER_0;
  tcfg.duty_resolution  = LEDC_TIMER_8_BIT;     // 8 bits -> 0..255
  tcfg.freq_hz          = LEDC_FREQ_HZ;         // 5 kHz
  tcfg.clk_cfg          = LEDC_AUTO_CLK;
  ledc_timer_config(&tcfg);

  ledc_channel_config_t ccfg = {};
  ccfg.gpio_num       = PIN_PELTIER;
  ccfg.speed_mode     = LEDC_LOW_SPEED_MODE;
  ccfg.channel        = LEDC_CHANNEL_0;
  ccfg.intr_type      = LEDC_INTR_DISABLE;
  ccfg.timer_sel      = LEDC_TIMER_0;
  ccfg.duty           = 0;
  ccfg.hpoint         = 0;
  ledc_channel_config(&ccfg);

  peltier_setDuty(0);

  // ---------- Servo ----------
  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  ESP32PWM::allocateTimer(2);
  ESP32PWM::allocateTimer(3);
  meshServo.setPeriodHertz(50);
  meshServo.attach(PIN_SERVO, 500, 2400);
  meshServo.write(servoPos);

  // ---------- Sensores ----------
  ds18b20.begin();
  dht.begin();

  // ---------- I2C + RTC ----------
  Wire.begin(); // SDA=21, SCL=22 por defecto
  if(!rtc.begin()){ Serial.println("RTC no detectado. Continuo con millis()/NTP."); }

  // ---------- LED alarma ----------
  pinMode(PIN_LED_ALARMA, OUTPUT);
  digitalWrite(PIN_LED_ALARMA, LOW);

  // ---------- RTOS IPC ----------
  qSensors = xQueueCreate(1, sizeof(SensorFrame));
  semCtrl  = xSemaphoreCreateBinary();
  snapMtx  = xSemaphoreCreateMutex();

  // ---------- Timer de control (API vieja) ----------
  ctrlTimer = timerBegin(1000000); // 1 MHz
  timerAttachInterrupt(ctrlTimer, &onCtrlTimer);
  timerAlarm(ctrlTimer, (uint64_t)CTRL_TICK_MS * 1000ULL, true, 0);

  // ---------- Rutas UI ----------
  server.on("/", handleIndex);
  server.on("/api/last", handleApiLast);

  // ---------- Tareas ----------
  xTaskCreatePinnedToCore(SensorTask, "SensorTask", 4096, nullptr, 2, &hSensorTask, 1);
  xTaskCreatePinnedToCore(ControlTask,"ControlTask",4096, nullptr, 3, &hControlTask, 0);
  xTaskCreatePinnedToCore(LoggerTask, "LoggerTask", 4096, nullptr, 1, &hLoggerTask, 1);
  xTaskCreatePinnedToCore(ServoTask,  "ServoTask",  4096, nullptr, 1, &hServoTask,  1);
  xTaskCreatePinnedToCore(SenderTask, "SenderTask", 4096, nullptr, 1, &hSenderTask, 1);

  Serial.println("Sistema iniciado.");
}

void loop(){
  vTaskDelay(portMAX_DELAY); // todo corre en FreeRTOS
}

